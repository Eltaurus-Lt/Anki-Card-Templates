{{#Learnable}}{{#Definition}}
<setting id="static_keys">qwerty</setting>
<setting id="random_keys"></setting>
<data id="correctAnswer">{{Learnable}}</data>
<data id="choices">{{Choices}}</data>

<div class="card-content front" theme="MemRise">

	<div class="overhead">
		<div class="mem-instruction">
			Type the correct translation
		</div>
		{{#Extra}}
			<div class="front-extra no-alts">
				<label>Extra</label>
				<span>{{Extra}}</span>
			</div>
		{{/Extra}}
	</div>

	<div class="mem-question no-alts memblob">
		<div>{{Definition}}</div>
	</div>

	<div class="mem-typing">
		<label>Learnable</label>
		<input id="typeans" type="text" inputmode="text" autocorrect="off" autocomplete="off" autocapitalize="off" spellcheck="false">
	</div>

	<timer class="off"></timer>

	<div id="scr-keyboard" class="">
		<div id="HintButton" class="membtn"><svg><path></path></svg>Hint</div>
	</div>

</div>
<a id="Lt" href="https://github.com/Eltaurus-Lt/Anki-Card-Templates"></a>
{{/Definition}}{{/Learnable}}




<!-- -------------------⚙️ user prior scripts ⚙️------------------ -->
<script>
  //place your scripts here


</script>

<!-- ---------------------  template scripts  --------------------- -->
<!--
This section (up until the line containing "End of code by Eltaurus") is part of the Anki Card Type template.
Source: github.com/Eltaurus-Lt/Anki-Card-Templates

Copyright © 2023-2024 Eltaurus
Contact: 
    Email: Eltaurus@inbox.lt
    GitHub: github.com/Eltaurus-Lt
    Anki Forums: forums.ankiweb.net/u/Eltaurus

This template is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This template is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this template. If not, see <http://www.gnu.org/licenses/>.

You are free to use this template to create your own Anki cards and decks, modify the code, and openly share the derivative works, provided that this copyright notice and similar notices in other parts remain intact (as covered by section 7b of the GPLv3 license). 
Clarification: The copyright in this notice applies only to the above-stated section of the code. In particular, it does not extend to data contained within fields of Anki cards or any media files included in Anki decks created using this template. It also does not cover any scripts or HTML code that may be added to this HTML file (Front Template screen) by creators of derivative cards/templates. Creators are encouraged to add their own copyright statements alongside their code in a similar fashion.
-->

<script>
//determine card side
wrap = document.getElementById('backwrap');
isFrontSide = !wrap;
</script>

<script>
//determine input flags
isMCh = !!document.querySelector('.card-content.mch');
isMathJax = !!document.querySelector('.card-content.eq');
</script>

<script>
//determine platform
platform = '';
if (!document.documentElement.classList.contains("mobile")) {
	platform = 'desk';
} else if (document.documentElement.classList.contains("android")) {
	//var jsApiContract = { version: "0.0.3", developer: "eltaurus@inbox.lt" };
	//var api = new AnkiDroidJS(jsApiContract);
	platform = 'android';
} else {
	platform = 'ios';
}
</script>

<script>
function htmlEscape(string) {
  return string.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll("'", '&#39;').replaceAll('"', '&quot;');
}

function htmlUnEscape(string) {
  return string.replaceAll('&lt;', '<').replaceAll('&gt;', '>').replaceAll('&#39;', "'").replaceAll('&quot;', '"').replaceAll('&amp;', '&');
}

function ansCleanUp(ansString) {
  return ansString?.replaceAll("&nbsp;"," ")?.trim();
}
</script>

<script>
//elements
typeAns = document.getElementById('typeans');
screenKeyboard = document.getElementById('scr-keyboard');
hintButton = document.getElementById('HintButton');
</script>

<script>
//MathJax
function MJwrap(latexString) {
  if ((latexString.startsWith("\\\x28") && latexString.endsWith("\\\x29")) || !latexString) {
    return latexString;
  }
  return "\\\x28" + latexString + "\\\x29";
}

function MJunwrap(latexString) {
  if (latexString.startsWith("\\\x28") && latexString.endsWith("\\\x29")) {
    return latexString.slice(2, -2);
  }
  return latexString;
}

async function MJconvert(latexString) {
  if (!window.MathJax) {
    console.log("MathJax not found");
    return latexString;
  }
  if (latexString.includes("mjx-container")) {
    return latexString;
  }
  const latexL = document.createElement('div');
  latexL.innerHTML = MJwrap(latexString);
  await MathJax.typesetPromise([latexL]);

  return latexL.innerHTML;
}

async function cfWithMathJax(sQ, sA) {
  const mathJaxRegex = /<mjx-container[^>]*>/g;

  return sQ.replace(mathJaxRegex, '') === sA.replace(mathJaxRegex, '') || (await MJconvert(sQ)).replace(mathJaxRegex, '') === sA.replace(mathJaxRegex, '') || (await MJconvert(sQ)).replace(mathJaxRegex, '') === (await MJconvert(sA)).replace(mathJaxRegex, '');
}
</script>

<script>
function storeAnswer(ans = "") {
	if (!ans && typeAns) {ans = typeAns.value};
	sessionStorage.setItem("userAnswer", ans);
}

if (isFrontSide) {
	storeAnswer("");
}
</script>

<script>
//determine the correct answer
corrAnsL = document.getElementById('correctAnswer');
corrAns = ansCleanUp(corrAnsL?.innerHTML) || ""; //including alts

//extract primary, excluding alts
try {
	const tempL = document.createElement('div');
	tempL.innerHTML = corrAns;
	tempL.querySelectorAll('[part="alt"]').forEach((L) => {L.remove();});
	corrAns = ansCleanUp(!isMCh ? tempL.innerText : tempL.innerHTML);
	tempL.remove();
} catch (err) {}

inlnAlts = corrAns.split(/[;；]/).map(ansCleanUp);

hintAns = inlnAlts[0];
if (isMathJax) {
	hintAns = MJunwrap(hintAns);
	if (isMCh) {
		inlnAlts = []; //otherwise is split at ';' in '&gt;', '&lt;', etc.
	}
}

//determine alt answers
partAlts = [];
try {
	const altsString = [...corrAnsL.querySelectorAll('[part="alt"]')].map(L => L.innerText).join('|');
	partAlts = altsString ? altsString.split('|').map(ansCleanUp) : [];
} catch (err) {}

allAlts = [...inlnAlts, ...partAlts];
</script>

<script>
//consts
keysString = document.getElementById('static_keys')?.innerText || "";
fillerString = document.getElementById('random_keys')?.innerText || "";
choices = document.getElementById('choices')?.innerHTML.split('|').map(ansCleanUp) || '';
</script>

<script>
//keyboard navigation
tabSelected = null;
document.onkeyup = function (e) {
	var ev = window.event || e;
	
	if (ev.key === 'Tab') {
		tabSelected = document.activeElement;
	}
}

document.onkeydown = function (e) {
	var ev = window.event || e;

	if (ev.key === 'Enter' && (tabSelected !== document.activeElement || tabSelected?.id === 'typeans')) {
		//last action was NOT selecting element with Tab -> Enter=flip (prevent audio activation)
		if (document.activeElement.matches('a.replay-button.soundLink')) {
			document.activeElement.blur();
		}
		if (!isFrontSide) {
			if (flipBtn && flipBtn.onclick) {
				flipBtn.onclick();
			}
		} else {
			flipToBack();
		}
	}

	if (!isFrontSide && ev.code === 'Space') {
		if (wrap.classList.contains("backside")) {
			return;
		}
		e.preventDefault();
		MemFlip(true);
	}

	if (isFrontSide && "1234567890".includes(ev.key) && isMCh) {
		let numkey = parseInt(ev.key);
		if (numkey == 0) {numkey = 10};
		const mchoiceButtons = screenKeyboard.querySelectorAll('.membtn');
		if (numkey <= mchoiceButtons.length) {
			mchoiceButtons[numkey - 1].onclick();
		}
	}

	if (!isFrontSide && "1234".includes(ev.key)) {
		try {
			pycmd('ease' + ev.key);
		} catch(err) {}
	}
}
</script>

<script>
//Audio buttons animation
audioButtonsFront = document.querySelectorAll('.card-content.front a.replay-button');
audioButtonsFront.forEach((a) => {
	a.addEventListener("click", () => {
		audioButtonsFront.forEach((b) => {
			b.classList.remove('active');
		});
    a.classList.add('active');

		a.classList.remove('pulse');
		void a.offsetHeight;
		a.classList.add('pulse');
	});
});
if (audioButtonsFront && audioButtonsFront.length > 0) {
	audioButtonsFront[0].classList.add('active');
	audioButtonsFront[0].classList.add('pulse');
}
</script>

<script>
//on-screen keyboard | mult-choice buttons

function shuffle(arr) {
  return arr.sort(() => 0.5 - Math.random());
}

if (screenKeyboard) {
	if (isFrontSide) {
		if (fillerString && corrAns && !isMCh) {
			//character keys
			if (typeof window.randomKeysN !== 'number') {randomKeysN = 10} //fallback
			neededKeys = shuffle(fillerString.split('')).slice(0, randomKeysN);
			neededKeys = shuffle([... new Set([...(corrAns.split('')), ...neededKeys])]);
			neededKeys = neededKeys.filter(key => !keysString.includes(key));
			keysString = neededKeys.join('') + keysString;
		} else if (isMCh) {
			//multiple-choice keys
			choices = choices.filter(choice => (choice !== corrAns && !!choice));
			choices = shuffle([... new Set(choices)]);
			choices.splice((window.mchOptionsN || 6) - 1);
			choices = [corrAns, ...choices];
			shuffle(choices);
			keysString = choices.join('|');
		}

		sessionStorage.setItem("card-keyboard", keysString);
	} else {
		keysString = sessionStorage.getItem("card-keyboard") || "";
	}

	if (!isMCh) {
	  keys = keysString.split('');
	} else {
		keys = keysString ? keysString.split('|') : [];
		screenKeyboard.innerHTML = '';
	}
  keys.reverse().forEach((key)=>{
    const keyButton = document.createElement("div");
    if (!isMCh) {
      keyButton.innerText = key;
    } else {
      keyButton.innerHTML = key;
    }
    keyButton.classList.add('membtn');
    if (!isMCh && (key === ' ' || key === '　')) {keyButton.classList.add('space')}
    if (isMCh) {
      if (key === corrAns || allAlts.includes(key)) {
        keyButton.classList.add('correct')
      } else if (isMathJax && MJwrap(key) === corrAns) {
        keyButton.classList.add('correct')
      } else if (isMathJax) {
        allAlts.map(async (altAns) => cfWithMathJax(altAns, key).then((res) => {
          if (res) {keyButton.classList.add('correct')}
        }));
      }
    }
    screenKeyboard.prepend(keyButton);
  })
} 
</script>

<script>
delete window.randomKeysN;
delete window.mchOptionsN;
</script>

<script>
/*keyboard key functions*/
keyboardButtons = document.querySelectorAll('#scr-keyboard > *');

function flipToBack() {
	if (!isFrontSide) return;
	if (platform === 'desk') {
		pycmd("ans");
	} else if (platform === 'android') {
		showAnswer();
	}
	console.log('flip');
}

function lengthOfCommonPart(str1, str2) {
	const minLength = Math.min(str1.length, str2.length);
	let i; 
	for (i = 0; str1[i] == str2[i] && i < minLength; i++) {}
	return i;
}

function updInput(inputValue, cursorPos = null) {
	if (!typeAns) return;

	typeAns.value = inputValue;
	typeAns.setSelectionRange(cursorPos || inputValue.length, cursorPos || inputValue.length);

	storeAnswer();

	typeAns.focus(); // Android quirk (doesn't seem to update cursor position without this)
	if (platform !== 'desk') {
		typeAns.blur();
	}
}

function typeHint() {
	if (!hintAns || !typeAns) return;
	const tempAns = window.isMathJax && typeAns.value.startsWith('\\\x28') ? typeAns.value.slice(2) : typeAns.value;
	const correctLength = lengthOfCommonPart(tempAns, hintAns);

	if (correctLength < hintAns.length) {
		updInput(hintAns.slice(0, correctLength + 1));

	} else if (typeAns.value.length > correctLength) {
		updInput(hintAns);

	} else {
		flipToBack();
	}
}

function typeKey(keyContent) {
	if (!typeAns) return;
	const cursorStart = typeAns.selectionStart;
	const cursorEnd = typeAns.selectionEnd;
	const currentInput = typeAns.value;

	updInput(currentInput.slice(0, cursorStart) + htmlUnEscape(keyContent) + currentInput.slice(cursorEnd), cursorStart + 1);}

if (isFrontSide) {
	keyboardButtons.forEach( btn => {
		if (btn.id === 'HintButton') {
			btn.onclick = typeHint;
		} else if (isMCh) {
			btn.onclick = ()=>{
				if (btn.classList.contains('pressed')) {
					storeAnswer("");
					btn.classList.remove('pressed');
				} else {
					storeAnswer(btn.innerHTML);
					keyboardButtons.forEach((b) => {
						b.classList.remove('pressed');
					});
					btn.classList.add('pressed');
				}
				flipToBack();
			};
		} else if (typeAns) {
			btn.onclick = ()=>{
				typeKey(btn.innerHTML); //innerText does not work for space
			};
		}
	});

	if (typeAns) {
		typeAns.addEventListener('input', (event) => {storeAnswer();});
	}
}
</script>
<!-- End of code by Eltaurus -->

<!-- -------------------⚙️ user posterior scripts ⚙️------------------ -->
<script>
  //place your scripts here


</script>