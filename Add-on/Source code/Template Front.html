{{#Learnable}}{{#Definition}}
<setting id="static_keys">-+*/^_\{}()[]<>=</setting>
<setting id="random_keys"></setting>
<data id="correctAnswer">{{Learnable}}</data>
<data id="choices">{{Choices}}</data>
<div class="card-content front mch eq" theme="">
    <div class="overhead">
		   <div class="mem-instruction">
        Type the correct LaTeX expression
      </div>
			 {{#Extra}}
					<div class="front-extra">
						<label>Extra</label>
						<span>{{Extra}}</span>
					</div>
				{{/Extra}}
    </div>
    <div class="mem-question memblob">
      <div>{{Definition}}</div>
    </div>
    <div class="mem-typing">
      <label>Learnable</label>
      <input id="typeans" type="text" inputmode="text" autocorrect="off" autocomplete="off" autocapitalize="off" spellcheck="false">
    </div>
		<timer class="off"></timer>
    <div id="scr-keyboard" class="">
      <div id="HintButton" class="membtn"><svg><path></path></svg>Hint</div>
    </div>
</div>
<a id="Lt" href="https://github.com/Eltaurus-Lt/Anki-Card-Templates"></a>
{{/Definition}}{{/Learnable}}




<!-- --------------------- user prior scripts --------------------- -->
<script>
  //place your scripts here


</script>

<!-- ---------------------  template scripts  --------------------- -->
<script>
//determine card side
wrap = document.getElementById('backwrap');
isFrontSide = !wrap;
</script>

<script>
//determine input flags
isMCh = !!document.querySelector('.card-content.mch');
isMathJax = !!document.querySelector('.card-content.eq');
</script>

<script>
//determine platform
platform = '';
if (!document.documentElement.classList.contains("mobile")) {
	platform = 'desk';
} else if (document.documentElement.classList.contains("android")) {
	//var jsApiContract = { version: "0.0.3", developer: "eltaurus@inbox.lt" };
	//var api = new AnkiDroidJS(jsApiContract);
	platform = 'android';
} else {
	platform = 'ios';
}
</script>

<script>
function htmlEscape(string) {
  return string.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll("'", '&#39;').replaceAll('"', '&quot;');
}

function htmlUnEscape(string) {
  return string.replaceAll('&lt;', '<').replaceAll('&gt;', '>').replaceAll('&#39;', "'").replaceAll('&quot;', '"').replaceAll('&amp;', '&');
}

function ansCleanUp(ansString) {
  return ansString?.replaceAll("&nbsp;"," ")?.trim();
}
</script>

<script>
//elements
typeAns = document.getElementById('typeans');
screenKeyboard = document.getElementById('scr-keyboard');
hintButton = document.getElementById('HintButton');
</script>

<script>
//MathJax
function MJwrap(latexString) {
  if ((latexString.startsWith("\\\x28") && latexString.endsWith("\\\x29")) || !latexString) {
    return latexString;
  }
  return "\\\x28" + latexString + "\\\x29";
}

function MJunwrap(latexString) {
  if (latexString.startsWith("\\\x28") && latexString.endsWith("\\\x29")) {
    return latexString.slice(2, -2);
  }
  return latexString;
}

async function MJconvert(latexString) {
  if (!window.MathJax) {
    console.log("MathJax not found");
    return latexString;
  }
  if (latexString.includes("mjx-container")) {
    return latexString;
  }
  const latexL = document.createElement('div');
  latexL.innerHTML = MJwrap(latexString);
  await MathJax.typesetPromise([latexL]);

  return latexL.innerHTML;
}

async function cfWithMathJax(sQ, sA) {
  const mathJaxRegex = /<mjx-container[^>]*>/g;

  return sQ.replace(mathJaxRegex, '') === sA.replace(mathJaxRegex, '') || (await MJconvert(sQ)).replace(mathJaxRegex, '') === sA.replace(mathJaxRegex, '') || (await MJconvert(sQ)).replace(mathJaxRegex, '') === (await MJconvert(sA)).replace(mathJaxRegex, '');
}
</script>

<script>
function storeAnswer(ans = "") {
	if (!ans && typeAns) {ans = typeAns.value};
	sessionStorage.setItem("userAnswer", ans);
}

if (isFrontSide) {
	storeAnswer("");
}
</script>

<script>
//determine the correct answer
corrAnsL = document.getElementById('correctAnswer');
corrAns = ansCleanUp(corrAnsL?.innerHTML) || ""; //including alts

//extract primary, excluding alts
try {
	const tempL = document.createElement('div');
	tempL.innerHTML = corrAns;
	tempL.querySelectorAll('[part="alt"]').forEach((L) => {L.remove();});
	corrAns = ansCleanUp(!isMCh ? tempL.innerText : tempL.innerHTML);
	tempL.remove();
} catch (err) {}

inlnAlts = corrAns.split(/[;；]/).map(ansCleanUp);

hintAns = inlnAlts[0];
if (isMathJax) {
	hintAns = MJunwrap(hintAns);
	if (isMCh) {
		inlnAlts = []; //otherwise is splite at ';' in '&gt;', '&lt;', etc.

	}
}

//determine alt answers
partAlts = [];
try {
	const altsString = [...corrAnsL.querySelectorAll('[part="alt"]')].map(L => L.innerText).join('|');
	partAlts = altsString ? altsString.split('|').map(ansCleanUp) : [];
} catch (err) {}

allAlts = [...inlnAlts, ...partAlts];
</script>

<script>
//consts
keysString = document.getElementById('static_keys')?.innerText || "";
fillerString = document.getElementById('random_keys')?.innerText || "";
choices = document.getElementById('choices')?.innerHTML.split('|').map(ansCleanUp) || '';
</script>

<script>
//keyboard navigation
tabSelected = null;
document.onkeyup = function (e) {
	var ev = window.event || e;
	
	if (ev.key === 'Tab') {
		tabSelected = document.activeElement;
	}
}

document.onkeydown = function (e) {
	var ev = window.event || e;

	if (ev.key === 'Enter' && (tabSelected !== document.activeElement || tabSelected?.id === 'typeans')) {
		//last action was NOT selecting element with Tab -> Enter=flip (prevent audio activation)
		if (document.activeElement.matches('a.replay-button.soundLink')) {
			document.activeElement.blur();
		}
		if (!isFrontSide) {
			if (flipBtn && flipBtn.onclick) {
				flipBtn.onclick();
			}
		} else {
			flipToBack();
		}
	}

	if (!isFrontSide && ev.code === 'Space') {
		if (wrap.classList.contains("backside")) {
			return;
		}
		e.preventDefault();
		MemFlip(true);
	}

	if (isFrontSide && "1234567890".includes(ev.key) && isMCh) {
		let numkey = parseInt(ev.key);
		if (numkey == 0) {numkey = 10};
		const mchoiceButtons = screenKeyboard.querySelectorAll('.membtn');
		if (numkey <= mchoiceButtons.length) {
			mchoiceButtons[numkey - 1].onclick();
		}
	}

	if (!isFrontSide && "1234".includes(ev.key)) {
		try {
			pycmd('ease' + ev.key);
		} catch(err) {}
	}
}
</script>

<script>
//Audio buttons animation
audioButtonsFront = document.querySelectorAll('.card-content.front a.replay-button');
audioButtonsFront.forEach((a) => {
	a.addEventListener("click", () => {
		audioButtonsFront.forEach((b) => {
			b.classList.remove('active');
		});
    a.classList.add('active');

		a.classList.remove('pulse');
		void a.offsetHeight;
		a.classList.add('pulse');
	});
});
if (audioButtonsFront && audioButtonsFront.length > 0) {
	audioButtonsFront[0].classList.add('active');
	audioButtonsFront[0].classList.add('pulse');
}
</script>

<script>
//on-screen keyboard | mult-choice buttons

function shuffle(arr) {
  return arr.sort(() => 0.5 - Math.random());
}

if (screenKeyboard) {
	if (isFrontSide) {
		if (fillerString && corrAns && !isMCh) {
			//character keys
			if (typeof window.randomKeysN !== 'number') {randomKeysN = 10} //fallback
			neededKeys = shuffle(fillerString.split('')).slice(0, randomKeysN);
			neededKeys = shuffle([... new Set([...(corrAns.split('')), ...neededKeys])]);
			neededKeys = neededKeys.filter(key => !keysString.includes(key));
			keysString = neededKeys.join('') + keysString;
		} else if (isMCh) {
			//multiple-choice keys
			choices = choices.filter(choice => (choice !== corrAns && !!choice));
			choices = shuffle([... new Set(choices)]);
			choices.splice((window.mchOptionsN || 6) - 1);
			choices = [corrAns, ...choices];
			shuffle(choices);
			keysString = choices.join('|');
		}

		sessionStorage.setItem("card-keyboard", keysString);
	} else {
		keysString = sessionStorage.getItem("card-keyboard") || "";
	}

	if (!isMCh) {
	  keys = keysString.split('');
	} else {
		keys = keysString ? keysString.split('|') : [];
		screenKeyboard.innerHTML = '';
	}
  keys.reverse().forEach((key)=>{
    const keyButton = document.createElement("div");
    if (!isMCh) {
      keyButton.innerText = key;
    } else {
      keyButton.innerHTML = key;
    }
    keyButton.classList.add('membtn');
    if (!isMCh && (key === ' ' || key === '　')) {keyButton.classList.add('space')}
    if (isMCh) {
      if (key === corrAns || allAlts.includes(key)) {
        keyButton.classList.add('correct')
      } else if (isMathJax && MJwrap(key) === corrAns) {
        keyButton.classList.add('correct')
      } else if (isMathJax) {
        allAlts.map(async (altAns) => cfWithMathJax(altAns, key).then((res) => {
          if (res) {keyButton.classList.add('correct')}
        }));
      }
    }
    screenKeyboard.prepend(keyButton);
  })
} 
</script>

<script>
delete window.randomKeysN;
delete window.mchOptionsN;
</script>

<script>
/*keyboard key functions*/
keyboardButtons = document.querySelectorAll('#scr-keyboard > *');

function flipToBack() {
	if (!isFrontSide) return;
	if (platform === 'desk') {
		pycmd("ans");
	} else if (platform === 'android') {
		showAnswer();
	}
	console.log('flip');
}

function lengthOfCommonPart(str1, str2) {
	const minLength = Math.min(str1.length, str2.length);
	let i; 
	for (i = 0; str1[i] == str2[i] && i < minLength; i++) {}
	return i;
}

function updInput(inputValue, cursorPos = null) {
	if (!typeAns) return;

	typeAns.value = inputValue;
	typeAns.setSelectionRange(cursorPos || inputValue.length, cursorPos || inputValue.length);

	storeAnswer();

	typeAns.focus(); // Android doesn't seem to update cursor position without this
	if (platform !== 'desk') {
		typeAns.blur();
	}
}

function typeHint() {
	if (!hintAns || !typeAns) return;
	const tempAns = window.isMathJax && typeAns.value.startsWith('\\\x28') ? typeAns.value.slice(2) : typeAns.value;
	const correctLength = lengthOfCommonPart(tempAns, hintAns);

	if (correctLength < hintAns.length) {
		updInput(hintAns.slice(0, correctLength + 1));

	} else if (typeAns.value.length > correctLength) {
		updInput(hintAns);

	} else {
		flipToBack();
	}
}

function typeKey(keyContent) {
	if (!typeAns) return;
	const cursorStart = typeAns.selectionStart;
	const cursorEnd = typeAns.selectionEnd;
	const currentInput = typeAns.value;

	updInput(currentInput.slice(0, cursorStart) + htmlUnEscape(keyContent) + currentInput.slice(cursorEnd), cursorStart + 1);}

if (isFrontSide) {
	keyboardButtons.forEach( btn => {
		if (btn.id === 'HintButton') {
			btn.onclick = typeHint;
		} else if (isMCh) {
			btn.onclick = ()=>{
				if (btn.classList.contains('pressed')) {
					storeAnswer("");
					btn.classList.remove('pressed');
				} else {
					storeAnswer(btn.innerHTML);
					keyboardButtons.forEach((b) => {
						b.classList.remove('pressed');
					});
					btn.classList.add('pressed');
				}
				flipToBack();
			};
		} else if (typeAns) {
			btn.onclick = ()=>{
				typeKey(btn.innerHTML); //innerText does not work for space
			};
		}
	});

	if (typeAns) {
		typeAns.addEventListener('input', (event) => {storeAnswer();});
	}
}
</script>

<!-- --------------------- user posterior scripts --------------------- -->
<script>
  //place your scripts here


</script>